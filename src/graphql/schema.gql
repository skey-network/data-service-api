# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Meta {
  total: Int
  skip: Int
  take: Int
}

type Supplier {
  id: ID!
  address: String!
  whitelisted: Boolean!
  name: String
  description: String
  whitelist: [String!]!
  organisations: [String!]!
  createdAt: DateTime
  updatedAt: DateTime
  score: Float
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type PaginatedSuppliers {
  objects: [Supplier!]!
  meta: Meta!
}

type Organisation {
  id: ID!
  address: String!
  whitelisted: Boolean!
  name: String
  description: String
  users: [String!]!
  createdAt: DateTime
  updatedAt: DateTime
  score: Float
}

type PaginatedOrganisations {
  objects: [Organisation!]!
  meta: Meta!
}

type PhysicalAddress {
  addressLine1: String
  addressLine2: String
  city: String
  postcode: String
  state: String
  country: String
  number: String
  floor: String
}

type Details {
  deviceType: String
  deviceModel: String
  additionalDescription: String
  assetUrl: String
  url: String
  contactInfo: String
  physicalAddress: PhysicalAddress
}

type Device {
  id: ID!
  address: String!
  supplier: String
  owner: String
  name: String
  description: String
  lat: Float
  lng: Float
  alt: Float
  visible: Boolean
  active: Boolean
  connected: Boolean
  details: Details
  custom: String
  whitelist: [String!]!
  createdAt: DateTime
  updatedAt: DateTime
  whitelisted: Boolean
  score: Float
}

type PaginatedDevices {
  objects: [Device!]!
  meta: Meta!
}

type Key {
  id: ID!
  assetId: String!
  issuer: String
  owner: String
  name: String
  device: String
  validTo: Float
  issueTimestamp: Float
  burned: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  whitelisted: Boolean
  score: Float
  deviceName: String
}

type PaginatedKeys {
  objects: [Key!]!
  meta: Meta!
}

type Event {
  id: ID!
  txHash: String!
  sender: String
  device: String
  assetId: String
  action: String
  status: String
  createdAt: DateTime
  updatedAt: DateTime
  score: Float
}

type PaginatedEvents {
  objects: [Event!]!
  meta: Meta!
}

type SearchResults {
  devices: [Device!]!
  events: [Event!]!
  keys: [Key!]!
  organisations: [Organisation!]!
  suppliers: [Supplier!]!
  meta: Meta!
}

type Query {
  suppliers(
    """
    
      Order in which records will be sorted. Correct values are "asc" for ascending and "desc"
      for descending
    
    """
    order: String = "asc"

    """
    
      Field name used for sorting. For example { order: "desc", orderBy: "updatedAt" } returns 
      last updated items first.
    
    """
    orderBy: String

    """
    
      User to search for match in multiple fields. It appends new field (score) to returned items.
      For example query devices { search: "teltonika", order: "desc", orderby: "score" } returns devices that have
      "teltonika" string in one of the fields and places best matches first.
    
    """
    search: String

    """
    
      Used for pagination. Indicates how many records starting from the first one should be skipped.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page.
    
    """
    skip: Int = 0

    """
    
      Used for pagination. Indicates how many records should be returned in the current request.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page. Default value
      is 25. Maximum amount is 1000
    
    """
    take: Int = 25
    filter: SuppliersFilter = {}
  ): PaginatedSuppliers!
  supplier(address: String!): Supplier!
  organisations(
    """
    
      Order in which records will be sorted. Correct values are "asc" for ascending and "desc"
      for descending
    
    """
    order: String = "asc"

    """
    
      Field name used for sorting. For example { order: "desc", orderBy: "updatedAt" } returns 
      last updated items first.
    
    """
    orderBy: String

    """
    
      User to search for match in multiple fields. It appends new field (score) to returned items.
      For example query devices { search: "teltonika", order: "desc", orderby: "score" } returns devices that have
      "teltonika" string in one of the fields and places best matches first.
    
    """
    search: String

    """
    
      Used for pagination. Indicates how many records starting from the first one should be skipped.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page.
    
    """
    skip: Int = 0

    """
    
      Used for pagination. Indicates how many records should be returned in the current request.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page. Default value
      is 25. Maximum amount is 1000
    
    """
    take: Int = 25
    filter: OrganisationsFilter = {}
  ): PaginatedOrganisations!
  organisation(address: String!): Organisation!
  devices(
    """
    
      Order in which records will be sorted. Correct values are "asc" for ascending and "desc"
      for descending
    
    """
    order: String = "asc"

    """
    
      Field name used for sorting. For example { order: "desc", orderBy: "updatedAt" } returns 
      last updated items first.
    
    """
    orderBy: String

    """
    
      User to search for match in multiple fields. It appends new field (score) to returned items.
      For example query devices { search: "teltonika", order: "desc", orderby: "score" } returns devices that have
      "teltonika" string in one of the fields and places best matches first.
    
    """
    search: String

    """
    
      Used for pagination. Indicates how many records starting from the first one should be skipped.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page.
    
    """
    skip: Int = 0

    """
    
      Used for pagination. Indicates how many records should be returned in the current request.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page. Default value
      is 25. Maximum amount is 1000
    
    """
    take: Int = 25
    filter: DevicesFilter = {}

    """
    
      Retruns list of devices that are inside of selected rectangle. For example, for points [lat:49, lng: 16]
      as bottomLeft and [lat:54, lng:24] as upperRight, it's going to return all devices in Poland.
    
    """
    geoSearch: GeoSearchInput

    """
    
      Returns list of devices to which an address has keys. For example, User with address user_1 is
      the owner of keys key_1 and key_2, key_1 is for device_1 and key_2 is for device_2. There are
      also user_2, device_3 and key_3. The method will return [device_1, device_2]. This is helpful
      when user need a list of devices he can interact with.
    
    """
    keysOwner: String
  ): PaginatedDevices!
  device(address: String!): Device!
  keys(
    """
    
      Order in which records will be sorted. Correct values are "asc" for ascending and "desc"
      for descending
    
    """
    order: String = "asc"

    """
    
      Field name used for sorting. For example { order: "desc", orderBy: "updatedAt" } returns 
      last updated items first.
    
    """
    orderBy: String

    """
    
      User to search for match in multiple fields. It appends new field (score) to returned items.
      For example query devices { search: "teltonika", order: "desc", orderby: "score" } returns devices that have
      "teltonika" string in one of the fields and places best matches first.
    
    """
    search: String

    """
    
      Used for pagination. Indicates how many records starting from the first one should be skipped.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page.
    
    """
    skip: Int = 0

    """
    
      Used for pagination. Indicates how many records should be returned in the current request.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page. Default value
      is 25. Maximum amount is 1000
    
    """
    take: Int = 25
    filter: KeysFilter = {}
  ): PaginatedKeys!
  key(assetId: String!): Key!
  events(
    """
    
      Order in which records will be sorted. Correct values are "asc" for ascending and "desc"
      for descending
    
    """
    order: String = "asc"

    """
    
      Field name used for sorting. For example { order: "desc", orderBy: "updatedAt" } returns 
      last updated items first.
    
    """
    orderBy: String

    """
    
      User to search for match in multiple fields. It appends new field (score) to returned items.
      For example query devices { search: "teltonika", order: "desc", orderby: "score" } returns devices that have
      "teltonika" string in one of the fields and places best matches first.
    
    """
    search: String

    """
    
      Used for pagination. Indicates how many records starting from the first one should be skipped.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page.
    
    """
    skip: Int = 0

    """
    
      Used for pagination. Indicates how many records should be returned in the current request.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page. Default value
      is 25. Maximum amount is 1000
    
    """
    take: Int = 25
    filter: EventsFilter = {}
  ): PaginatedEvents!
  event(txHash: String!): Event!
  search(
    """
    
      Used for pagination. Indicates how many records starting from the first one should be skipped.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page.
    
    """
    skip: Int = 0

    """
    
      Used for pagination. Indicates how many records should be returned in the current request.
      For example, { skip: 20, take: 10 } equals 3 page and 10 items for each page. Default value
      is 25. Maximum amount is 1000
    
    """
    take: Int = 25
    input: String!
  ): SearchResults!
}

input SuppliersFilter {
  whitelisted: Boolean
}

input OrganisationsFilter {
  whitelisted: Boolean
}

input DevicesFilter {
  supplier: String
  owner: String
  visible: Boolean
  active: Boolean
  connected: Boolean
  whitelisted: Boolean
}

input GeoSearchInput {
  bottomLeft: Point!
  upperRight: Point!
}

input Point {
  lat: Float!
  lng: Float!
}

input KeysFilter {
  issuer: String
  owner: String
  name: String
  device: String
  burned: Boolean
}

input EventsFilter {
  sender: String
  device: String
  assetId: String
  action: String
  status: String
}
